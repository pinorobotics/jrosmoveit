/*
 * Copyright 2021 jrosmoveit project
 * 
 * Website: https://github.com/pinorobotics/jrosmoveit
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package pinorobotics.jrosmoveit.moveit_msgs;

import id.jrosmessages.Message;
import id.jrosmessages.MessageMetadata;
import id.jrosmessages.std_msgs.StringMessage;
import id.xfunction.XJson;
import java.util.Arrays;
import java.util.Objects;

/**
 * Definition for moveit_msgs/PlaceGoal ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION
 * DEFINITION ====== # An action for placing an object
 */
@MessageMetadata(name = PlaceGoalMessage.NAME, md5sum = "b5ff24625cebec440c18cd2e1d833764")
public class PlaceGoalMessage implements Message {

    static final String NAME = "moveit_msgs/PlaceGoal";

    /** which group to be used to plan for grasping */
    public StringMessage group_name = new StringMessage();

    /** the name of the attached object to place */
    public StringMessage attached_object_name = new StringMessage();

    /** a list of possible transformations for placing the object */
    public PlaceLocationMessage[] place_locations = new PlaceLocationMessage[0];

    /**
     * if the user prefers setting the eef pose (same as in pick) rather than the location of the
     * object, this flag should be set to true
     */
    public boolean place_eef;

    /**
     * the name that the support surface (e.g. table) has in the collision world can be left empty
     * if no name is available
     */
    public StringMessage support_surface_name = new StringMessage();

    /**
     * whether collisions between the gripper and the support surface should be acceptable during
     * move from pre-place to place and during retreat. Collisions when moving to the pre-place
     * location are still not allowed even if this is set to true.
     */
    public boolean allow_gripper_support_collision;

    /** Optional constraints to be imposed on every point in the motion plan */
    public ConstraintsMessage path_constraints = new ConstraintsMessage();

    /**
     * The name of the motion planner to use. If no name is specified, a default motion planner will
     * be used
     */
    public StringMessage planner_id = new StringMessage();

    /**
     * an optional list of obstacles that we have semantic information about and that can be
     * touched/pushed/moved in the course of placing; CAREFUL: If the object name 'all' is used,
     * collisions with all objects are disabled during the approach and retreat.
     */
    public StringMessage[] allowed_touch_objects = new StringMessage[0];

    /** The maximum amount of time the motion planner is allowed to plan for */
    public double allowed_planning_time;

    /** Planning options */
    public PlanningOptionsMessage planning_options = new PlanningOptionsMessage();

    public PlaceGoalMessage withGroupName(StringMessage group_name) {
        this.group_name = group_name;
        return this;
    }

    public PlaceGoalMessage withAttachedObjectName(StringMessage attached_object_name) {
        this.attached_object_name = attached_object_name;
        return this;
    }

    public PlaceGoalMessage withPlaceLocations(PlaceLocationMessage... place_locations) {
        this.place_locations = place_locations;
        return this;
    }

    public PlaceGoalMessage withPlaceEef(boolean place_eef) {
        this.place_eef = place_eef;
        return this;
    }

    public PlaceGoalMessage withSupportSurfaceName(StringMessage support_surface_name) {
        this.support_surface_name = support_surface_name;
        return this;
    }

    public PlaceGoalMessage withAllowGripperSupportCollision(
            boolean allow_gripper_support_collision) {
        this.allow_gripper_support_collision = allow_gripper_support_collision;
        return this;
    }

    public PlaceGoalMessage withPathConstraints(ConstraintsMessage path_constraints) {
        this.path_constraints = path_constraints;
        return this;
    }

    public PlaceGoalMessage withPlannerId(StringMessage planner_id) {
        this.planner_id = planner_id;
        return this;
    }

    public PlaceGoalMessage withAllowedTouchObjects(StringMessage... allowed_touch_objects) {
        this.allowed_touch_objects = allowed_touch_objects;
        return this;
    }

    public PlaceGoalMessage withAllowedPlanningTime(double allowed_planning_time) {
        this.allowed_planning_time = allowed_planning_time;
        return this;
    }

    public PlaceGoalMessage withPlanningOptions(PlanningOptionsMessage planning_options) {
        this.planning_options = planning_options;
        return this;
    }

    @Override
    public int hashCode() {
        return Objects.hash(
                group_name,
                attached_object_name,
                Arrays.hashCode(place_locations),
                place_eef,
                support_surface_name,
                allow_gripper_support_collision,
                path_constraints,
                planner_id,
                Arrays.hashCode(allowed_touch_objects),
                allowed_planning_time,
                planning_options);
    }

    @Override
    public boolean equals(Object obj) {
        var other = (PlaceGoalMessage) obj;
        return Objects.equals(group_name, other.group_name)
                && Objects.equals(attached_object_name, other.attached_object_name)
                && Arrays.equals(place_locations, other.place_locations)
                && place_eef == other.place_eef
                && Objects.equals(support_surface_name, other.support_surface_name)
                && allow_gripper_support_collision == other.allow_gripper_support_collision
                && Objects.equals(path_constraints, other.path_constraints)
                && Objects.equals(planner_id, other.planner_id)
                && Arrays.equals(allowed_touch_objects, other.allowed_touch_objects)
                && allowed_planning_time == other.allowed_planning_time
                && Objects.equals(planning_options, other.planning_options);
    }

    @Override
    public String toString() {
        return XJson.asString(
                "group_name", group_name,
                "attached_object_name", attached_object_name,
                "place_locations", place_locations,
                "place_eef", place_eef,
                "support_surface_name", support_surface_name,
                "allow_gripper_support_collision", allow_gripper_support_collision,
                "path_constraints", path_constraints,
                "planner_id", planner_id,
                "allowed_touch_objects", allowed_touch_objects,
                "allowed_planning_time", allowed_planning_time,
                "planning_options", planning_options);
    }
}
